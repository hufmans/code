### epoll底层原理
epoll 是 Linux 提供的高效 I/O 多路复用机制，用于监视多个文件描述符，通知程序哪些文件描述符可以执行读或写操作。相比于早期的 select 和 poll，epoll 提供了更好的性能，尤其在处理大量文件描述符时。

epoll 的底层原理主要包括以下几个方面：
事件驱动模型 (Event-Driven Model)： epoll 采用事件驱动的方式工作。程序将文件描述符注册到 epoll 对象中，epoll 内核会跟踪这些描述符的状态变化。一旦某个文件描述符准备好读或写操作，内核会将事件通知给应用程序，而不是轮询所有的文件描述符。

epoll 对象和红黑树 (Red-Black Tree)： 内核为每个 epoll 实例维护一棵红黑树，这棵树用于存储当前注册的文件描述符。红黑树的特点是插入、删除和查找操作的时间复杂度为 O(log n)，因此当处理大量文件描述符时，epoll 比 select 和 poll 更高效。

就绪队列 (Ready List)： 当文件描述符的状态发生变化时，epoll 会将其添加到就绪队列中。就绪队列是一个双向链表，用于存储那些已经触发事件的文件描述符。这意味着，epoll_wait() 调用只需要查看就绪队列，而不需要扫描所有注册的文件描述符，从而极大提升性能。

水平触发 (Level-Triggered) 和边缘触发 (Edge-Triggered)：

水平触发 (Level-Triggered, LT) 是默认模式，类似于 poll。当文件描述符准备好时，epoll_wait() 会持续返回该文件描述符，直到应用程序将事件处理完成。
边缘触发 (Edge-Triggered, ET) 仅在文件描述符状态变化时返回事件，且只返回一次。这种模式下，应用程序需要尽快处理完所有数据，否则可能会错过事件。
内存映射 (mmap)： epoll 的另一个性能优化是使用内存映射 (mmap) 机制，将用户空间和内核空间的就绪队列共享。通过内存映射，避免了内核和用户空间之间的拷贝操作，提高了系统调用效率。

epoll 的非阻塞模式： 结合非阻塞 I/O，epoll 可以在不阻塞应用程序的情况下等待 I/O 事件。这与传统的 select 或 poll 的阻塞模式相比，进一步提升了 I/O 多路复用的灵活性。

epoll 的三个主要系统调用：
epoll_create: 创建一个 epoll 实例，返回一个文件描述符。
epoll_ctl: 注册、修改或删除需要监控的文件描述符。
epoll_wait: 等待事件发生，返回就绪的文件描述符列表。
优点：
可扩展性：epoll 支持大量文件描述符的管理，随着文件描述符数量增加，性能基本保持稳定。
事件驱动：使用就绪队列，避免轮询所有描述符。
高效：通过红黑树和内存映射优化操作速度。

### epoll wait具体实现
epoll_wait() 是 epoll 中的核心函数，用于等待已经注册的文件描述符上发生的 I/O 事件。其底层实现可以通过内核态与用户态的交互以及一些关键的数据结构来理解。下面我们深入探讨 epoll_wait() 的具体实现。

1. 数据结构
在分析 epoll_wait() 之前，先理解它依赖的一些关键数据结构：

红黑树（rbtree）：epoll 使用红黑树来存储已注册的文件描述符。这棵树用于管理和查找监控的文件描述符，因此可以高效地注册和取消监控。

就绪队列（ready list）：这是一个双向链表，存储了发生了事件的文件描述符。当有文件描述符触发了 I/O 事件时，它们会被加入这个队列。

等待队列（wait queue）：epoll 还会将调用 epoll_wait() 的进程加入到一个等待队列中，如果没有任何事件发生，调用方会进入睡眠，等待事件触发时被唤醒。

2. epoll_wait() 的调用流程
epoll_wait() 的工作流程大致可以分为以下几个步骤：

(1) 检查就绪队列
当调用 epoll_wait() 时，首先会检查 epoll 实例的就绪队列。如果就绪队列中已经有文件描述符可用，epoll_wait() 会立即返回这些文件描述符，而不进入阻塞状态。

(2) 等待队列睡眠
如果就绪队列为空，epoll_wait() 会将当前调用进程加入 epoll 实例的等待队列，并进入睡眠状态，直到有新的 I/O 事件发生。进程被加入内核等待队列的过程是通过 schedule() 和 wait_event() 等内核调度机制实现的。

(3) 内核事件触发
当某个文件描述符上发生了 I/O 事件，内核会调用该文件描述符的回调函数（通过文件描述符的 poll 操作），并通过这个函数将该文件描述符从红黑树中移到就绪队列中。

(4) 唤醒等待进程
当有文件描述符被加入就绪队列时，内核会唤醒等待在等待队列中的进程。此时，epoll_wait() 从睡眠状态被唤醒，继续执行。

(5) 返回就绪的事件
epoll_wait() 会检查唤醒后的就绪队列，将触发事件的文件描述符拷贝到用户空间的数组中，并返回它们的数量。如果有多个文件描述符触发了事件，这些文件描述符会依次被拷贝并返回给用户空间。

3. 核心函数调用
在 epoll_wait() 的执行过程中，几个内核中的核心函数被频繁调用：

ep_poll()：这是 epoll_wait() 的实际实现函数，它负责遍历就绪队列，判断是否有可用的事件。

schedule()：如果没有事件发生，调用进程会通过 schedule() 进入睡眠状态。

wake_up()：当事件发生时，内核通过 wake_up() 唤醒等待在等待队列中的进程。

4. 非阻塞模式
如果 epoll_wait() 被设置为非阻塞模式（通过 epoll_create1() 设置 EPOLL_NONBLOCK），它会在没有事件的情况下立即返回，而不会进入等待队列。这种模式通常用于需要不断检查 I/O 事件的场景，比如在高性能服务器中使用。

5. 水平触发和边缘触发
水平触发 (Level-Triggered, LT)：当文件描述符有事件时，只要事件没有被处理完，每次调用 epoll_wait() 都会返回该文件描述符。

边缘触发 (Edge-Triggered, ET)：只有当文件描述符的状态从未就绪变为就绪时，epoll_wait() 才会返回该文件描述符，这种模式下如果应用程序没有及时处理事件，可能会错过后续的 I/O 事件。

6. 性能优化
epoll_wait() 的性能优化点在于：

避免全量轮询：与 select 和 poll 不同，epoll_wait() 只关注已经发生事件的文件描述符，避免了每次轮询整个文件描述符列表的开销。
使用内存映射 (mmap)：就绪队列的数据通过内存映射直接传递给用户空间，减少了内核和用户空间之间的数据拷贝。
唤醒机制的优化：通过内核调度机制，在事件触发时，调用进程会被高效地唤醒，而不是定期检查文件描述符状态。
epoll_wait() 的伪代码
以下是 epoll_wait() 的伪代码流程：

```c
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout) {
    // 1. 检查就绪队列
    if (!ready_list_empty()) {
        return copy_ready_events_to_user(events, maxevents);
    }

    // 2. 没有事件，进程进入睡眠
    if (timeout != 0) {
        add_process_to_wait_queue(current_process);
        schedule();  // 进程进入睡眠
    }
    
    // 3. 被唤醒后，检查就绪队列
    if (!ready_list_empty()) {
        return copy_ready_events_to_user(events, maxevents);
    }
    
    // 4. 超时或无事件发生
    return 0;

}
```

